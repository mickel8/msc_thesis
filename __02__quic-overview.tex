%! suppress = EscapeAmpersand


\section{QUIC overview}
\label{sec:quic-overview}
QUIC is a connection-based, multistream protocol that uses UDP/IP under the hood.
It is integrated with TLS and provides own congestion control and flow control mechanisms.
Data sent over QUIC is delivered in a reliable, ordered way.

This section outlines main features of QUIC and compares QUIC to the other transport protocols.

\subsection{Data structures}
\label{subsec:quic-data-structures}
The most outer entity in QUIC is a packet.
QUIC defines different types of packets.
Each packet consists of a header which is followed by a type-specific payload.

Header can take long or short form.
Packets with long headers are used at the beginning of the communication, before establishing 1-RTT keys.
After negotiating cryptographic context QUIC switches to the packet type with short header form for minimizing data sent
through the network.
Short header form is illustrated in figure~\ref{fig:short-header-format}.
It consists of miscellaneous flags which take one byte, optional destination connection ID and packet number.
Total size of Short Header is from 2 to 25 bytes.
On the other hand Long Header additionally includes version, destination connection ID length, source connection ID
length and source connection ID fields.
It misses packet number field and its flags differ a little comparing to the Short Header but they also take 1 byte.
Long header form is illustrated in figure~\ref{fig:long-header-format}.

\begin{figure}
    \centering
    \begin{bytefield}[bitwidth=4em]{8}
        \bitheader{0-7} \\
        \bitbox{1}{\tiny header form} & \bitbox{1}{\tiny fixed bit} & \bitbox{1}{\tiny spin bit} & \bitbox{2}{\tiny reserved bits} & \bitbox{1}{\tiny key phase} & \bitbox{2}{\tiny packet number length} \\
        \wordbox{1}{\tiny destination connection ID (0 - 160)} \\
        \wordbox{1}{\tiny packet number (8 - 32)}
    \end{bytefield}
    \caption{QUIC Short Header format}
    \label{fig:short-header-format}
\end{figure}

\begin{figure}
    \centering
    \begin{bytefield}[bitwidth=4em]{8}
        \bitheader{0-7} \\
        \bitbox{1}{\tiny header form} & \bitbox{1}{\tiny fixed bit} & \bitbox{2}{\tiny long packet type} & \bitbox{4}{\tiny Type-Specific Bits} \\
        \wordbox{4}{\tiny Version} \\
        \wordbox{1}{\tiny Destination Connection ID Length} \\
        \wordbox{1}{\tiny destination connection ID (0 - 160)} \\
        \wordbox{1}{\tiny Source Connection ID Length} \\
        \wordbox{1}{\tiny Source Connection ID (0 - 160)}
    \end{bytefield}
    \caption{QUIC Long Header format}
    \label{fig:long-header-format}
\end{figure}

QUIC defines following types of packets that use long header form: Version Negotiation, Initial, 0-RTT, Handshake, Retry and one packet type that uses short header form called 1-RTT\@.

Payload form depends on a packet type.
It includes type-specific fields which are in most cases followed by QUIC frames.
Payload can include many frames and many frame types.
Some of the QUIC frames are: PING, ACK, CRYPTO or STREAM\@.
Different frame types can appear only in specific packet types.
For example STREAM frame can only be included in 0-RTT or 1-RTT packets while CRYPTO frame can appear in Initial, Handshake or 1-RTT packets.
Version Negotiation, Stateless Reset, and Retry packets does not include any QUIC frames at all.

QUIC packets are directly encapsulated into UDP datagrams.
One UDP datagram can coalesce multiple QUIC packets.
The only requirement is that if there is a QUIC packet without length field present it has to be placed at the end of the UDP datagram.

\subsection{UDP based}
\label{subsec:udp-based}
As stated in the previous section, QUIC packets are directly encapsulated in UDP datagrams.
This makes QUIC user-level protocol which means it can be implement as a usual library without modifying operating system kernel.
On the other hand a lot of government institutions as well as companies blocks incoming or outgoing UDP traffic and allow
only for communication via TCP or TLS on port 443.

\subsection{Security}
\label{subsec:security}
QUIC is integrated with TLS 1.3 providing confidentiality, integrity and authenticity of its packets.
Integration with TLS 1.3 is described in details in RFC 9001~\cite{rfc9001}.
It is based on negotiating both transport and cryptographic parameters in a single connection handshake.
Encryption in QUIC is mandatory which means there is no possibility to send unencrypted data.
In addition, besides payload QUIC encrypts also some fields from header.
One of the questions this thesis aims to answer is whether QUIC encryption scheme introduces a significant overhead to the interactive communication.

\subsection{Connection establishment}
\label{subsec:connection-establishment}
Combining transport and cryptographic handshake results in significant reduction of connection establishment time.
Figure~\ref{fig:low-latency-conn-est} compares time needed for sending HTTP request using TCP/TLS and QUIC\@.

\begin{figure}[h]
    \centering
    \begin{subfigure}{.5\textwidth}
        \begin{sequencediagram}
            \newinst{client}{Client}
            \newinst[3]{server}{Server}
            \mess{client}{TCP SYN}{server}
            \mess{server}{TCP SYN + ACK}{client}
            \mess{client}{TCP ACK}{server}
            \postlevel
            \mess{client}{TLS ClientHello}{server}
            \mess{server}{TLS ServerHello}{client}
            \mess{client}{TLS Finished}{server}
            \postlevel
            \mess{client}{HTTP REQ}{server}
            \mess{server}{HTTP RES}{client}
        \end{sequencediagram}
        \caption{HTTP request in TCP}
        \label{subfig:http-req-tcp}
    \end{subfigure}%
    \begin{subfigure}{.5\textwidth}
        \begin{sequencediagram}
            \newinst{client}{Client}
            \newinst[3]{server}{Server}
            \mess{client}{QUIC}{server}
            \mess{server}{QUIC}{client}
            \mess{client}{QUIC}{server}
            \postlevel
            \mess{client}{HTTP REQ}{server}
            \mess{server}{HTTP RES}{client}
        \end{sequencediagram}
        \caption{HTTP request in QUIC}
        \label{subfig:http-req-quic}
    \end{subfigure}
    \caption{HTTP request comparison between TCP/TLS and QUIC}
    \label{fig:low-latency-conn-est}
\end{figure}

Round Trip Time (RTT) is a time needed for transporting a message from one side to the other and back again.
Standard HTTP request using TCP/TLS stack requires 3-RTT -- one for TCP handshake, one for TLS handshake and one for HTTP request.
Even though TCP handshake sends 3 messages it is still counted as 1-RTT as there is no need to wait for a response to the last message.
Instead, we can immediately send next data which is in this case data for TLS handshake.

QUIC takes another approach.
It combines transport and cryptographic handshakes reducing time needed for establishing a connection.
In such a case sending an HTTP request occurs after 1-RTT\@.
The whole communication lasts 2-RTT\@.

However, QUIC can reduce time needed for sending an HTTP request and receiving a response even more.
In case when there was communication with the server previously and client cached information from it, it is possible to send 0-RTT HTTP request.
This scenario is presented in figure~\ref{fig:http-req-quic-0rtt}
\begin{figure}
    \centering
    \begin{sequencediagram}
        \newinst{client}{Client}
        \newinst[3]{server}{Server}
        \mess{client}{QUIC}{server}
        \mess{client}{HTTP REQ}{server}
        \postlevel
        \mess{server}{QUIC}{client}
        \mess{server}{HTTP RES}{client}
        \postlevel
        \mess{client}{QUIC}{server}
    \end{sequencediagram}
    \caption{HTTP request in QUIC with 0-RTT packets}
    \label{fig:http-req-quic-0rtt}
\end{figure}

\FloatBarrier

\subsection{Streams}
\label{subsec:streams}
Stream is an ordered sequence of bytes.
Each stream can be unidirectional or bidirectional and can be opened by a client or by a server.
Different types of streams can have different flow control limits (see section~\ref{subsec:flow-control-and-congestion-control}).
One QUIC connection can multiplex many streams.
QUIC packets does not belong to streams -- i.e.\ they do not have any stream id field.
An entity that can be identified with stream is QUIC frame mainly STREAM frame but also other frame types like MAX\_STREAM\_DATA or STREAM\_DATA\_BLOCKED\@.
A QUIC implementation should also provide means to define stream priority.
Data that belongs to streams with lower (or higher) priority will be put on the wire before streams with higher (or lower)
priority.
Data in specific streams is carried independently which means that losing packet in one stream does not affect flow in other streams.
Figure~\ref{fig:stream-multiplexing} shows this scenario.
One of the packets in stream 1 (marked as gray) was lost and needs to be retransmitted blocking subsequent packets (marked as black) on the receiver side.
They cannot be conveyed to the application layer until retransmission and reordering of the lost packet.
This is the source of so called head of line blocking problem which appears when we are trying to multiplex many HTTP requests in a single TCP connection.
Losing one packet stops the entire flow.
However, thanks to the stream multiplexing QUIC resolves this problem and streams 2 and 3 are not affected by the packet loss in stream 1.

\begin{figure}
    \centering
    \begin{tikzpicture}

        \node[cylinder,
        draw = violet,
        text = purple,
        style={transform shape},
        cylinder uses custom fill,
        cylinder body fill = magenta!10,
        cylinder end fill = magenta!40,
        minimum size = 3.5cm] (c) at (0,0) {QUIC connection};

        \draw [->, postaction={decorate,decoration={raise=2ex, text along path,text align=center,text={stream 1}}}] (2, 1.5) -- (7.5, 1.5);
        \filldraw [fill=green!20, draw=black] (2.5, 1.25) rectangle (3.25, 1.75);
        \filldraw [fill=gray!20, draw=black] (3.75, 1.25) rectangle (4.5, 1.75);
        \filldraw [fill=black!60, draw=black] (5, 1.25) rectangle (5.75, 1.75);
        \filldraw [fill=black!60, draw=black] (6.25, 1.25) rectangle (7, 1.75);

        \draw [->, postaction={decorate,decoration={raise=2ex, text along path,text align=center,text={stream 2}}}] (2, 0) -- (7.5, 0);
        \filldraw [fill=cyan!20, draw=black] (2.5, -0.25) rectangle (3.25, 0.25);
        \filldraw [fill=cyan!20, draw=black] (3.75, -0.25) rectangle (4.5, 0.25);
        \filldraw [fill=cyan!20, draw=black] (5, -0.25) rectangle (5.75, 0.25);
        \filldraw [fill=cyan!20, draw=black] (6.25, -0.25) rectangle (7, 0.25);

        \draw [->, postaction={decorate,decoration={raise=2ex, text along path,text align=center,text={stream 3}}}] (2, -1.5) -- (7.5, -1.5);
        \filldraw [fill=red!20, draw=black] (2.5, -1.75) rectangle (3.25, -1.25);
        \filldraw [fill=red!20, draw=black] (3.75, -1.75) rectangle (4.5, -1.25);
        \filldraw [fill=red!20, draw=black] (5, -1.75) rectangle (5.75, -1.25);
        \filldraw [fill=red!20, draw=black] (6.25, -1.75) rectangle (7, -1.25);


    \end{tikzpicture}
    \caption{Stream multiplexing in a single QUIC connection}
    \label{fig:stream-multiplexing}
\end{figure}

\subsection{Connection migration}
\label{subsec:connection-migration}
Each QUIC connection has a set of connection identifiers each of which can identify the connection.
Connection IDs can be variable length.
QUIC uses connection IDs to route packets to proper endpoint.
This way, as long as there is an alternative network path, QUIC is resilient to network changes avoiding restarting the connection when an endpoint changes its transport address (IP or port).

\subsection{Flow control}
\label{subsec:flow-control-and-congestion-control}
Flow control is a mechanism which allows receiver to announce how much data it is able to process/buffer.
Sender must not exceed this limit until it is updated.
In QUIC, flow control limits can be set on two levels.
The first one is stream level.
This limit is set per stream type e.g.\ for all unidirectional streams opened by the peer or for all bidirectional streams opened locally.
There is no possibility to set flow control limit for a stream with a particular id.
The second one is connection level and it limits overall data amount that can be sent within the whole connection across all streams.
QUIC allows also for limiting number of streams that can be opened by the peer.
These limits are also set per stream type -- unidirectional or bidirectional and initiated by a peer or locally.

\subsection{Congestion control}
\label{subsec:congestion-control}
Congestion control also limits amount of data that can be transmitted by a sender but instead of protecting receiver it aims to prevent from overwhelming network middle-boxes like routers and if such overwhelm occurs it helps to recover from it.
RFC 9001~\cite{rfc9001} describes in details sender-side QUIC congestion controller similar to TCP NewReno.
It is triggered when one of QUIC packets is lost or when sender receives IP packet with ECN-CN flag set.
However, any other congestion controller that meets requirements defined in section 3.1 of RFC 8085~\cite{rfc8085} can be used.
This makes QUIC congestion control mechanism pluggable and allows for adapting congestion control algorithm to specific use case.

\subsection{Reliability}
\label{subsec:reliability}
QUIC is a reliable protocol which means it guarantees delivery of each packet sent by the endpoint.
Packets are delivered to the receiver side in the order they were sent.
However, there are different IETF drafts that expand QUIC with new features.
One of them called \textit{An Unreliable Datagram Extension to QUIC}\cite{bider-ssh-quic-09} allows for sending unreliable messages over QUIC\@.
This can take place in simultaneously to the reliable communication.
Unreliable messages are not subject to flow control mechanisms however, they are congestion controlled.
Each unreliable message is also acknowledged so that application layer can be provided with the packet loss information.
Section~\ref{subsec:partial-reliability} describes Datagram extension in details.

\subsection{QUIC against other transport protocols}
\label{subsec:quic_against_other_transport_protocols}
This section compares QUIC with three main transport protocols -- TCP, UDP and SCTP\@.

\subsubsection{TCP}
Transmission Control Protocol -- connection based, stream oriented and reliable transport protocol.
It guarantees the order of messages and provides flow control and congestion control mechanisms.
TCP is not a multiplexed protocol.
In one TCP connection we have one logical communication channel.
This is the reason of head of line blocking problem that appears when many HTTP/2 requests are multiplexed in one TCP connection.
Because of its reliability, TCP is not a good choice for many types of interactive communication.

\subsubsection{UDP}
User Datagram Protocol -- connection less, unreliable transport protocol.
It does not preserve the order of messages.
Datagrams, in this protocol, are not acknowledged nor congestion controlled.
It does not also introduce any flow control mechanisms.
Thanks to its simplicity and low bandwidth affection it is the base for RTP protocol which is widely used for transmitting multimedia.
Unlike TCP, UDP also allows for multicast transmission.
However, multicast is rarely used, mostly in local networks.

\subsubsection{SCTP}
Stream Control Transmission Protocol -- partially reliable, based on UDP, message oriented transport protocol.
Unlike TCP, SCTP is multistream protocol.
SCTP is partially ordered but it also allows for sending unordered messages.
Another feature of SCTP is multi-homing in which an endpoint uses two different addresses.
This introduces some kind of fault tolerance -- one address is designated as a primary and the other one can be used in case of failure of the first one.
Unfortunately SCTP is not widely used.
Its main domain is telecommunication as a lot of home routers does not handle it properly.

\subsubsection{Summary}
Table~\ref{tab:protocols_comparision} presents a short summary of transport protocols comparison.
\begin{table}[h]
    \centering
    \resizebox{\columnwidth}{!}{%
    \begin{tabular}{|c | c | c | c | c |}
        \hline
        & TCP           & UDP              & SCTP               & QUIC                \\
        \hline
        reliability        & reliable      & unreliable       & partially reliable & reliable/unreliable \\
        \hline
        transmission       & byte oriented & message oriented & message oriented   & byte oriented       \\
        \hline
        flow control       & yes           & no               & yes                & only for streams    \\
        \hline
        congestion control & yes           & no               & yes                & yes                 \\
        \hline
        packets order      & ordered       & unordered        & partially ordered  & ordered             \\
        \hline
        multistream        & no            & no               & yes                & yes                 \\
        \hline
    \end{tabular}%
    }
    \caption{\label{tab:protocols_comparision}Transport protocols comparison.}
\end{table}
